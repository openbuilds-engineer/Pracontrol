var SerialPort = null // lazy load

module.exports = class Serial extends WebComponentAbstract {
  init() {
    this.serial = null
    this.ports = []
    
    this.new(require('./Buffer'))
    
    defineEvent('refreshPorts', 'Reload port list', 'Serial')
    defineEvent('refreshPortsDone', 'Port are reloaded, listen only', 'Serial')
    defineEvent('newPort', 'New port found, listen only', 'Serial', '{ }')
    self.on('refreshPorts', e => this.refreshPorts())
    
    defineEvent('connect', 'Attempt to connect', 'Serial', `{ portName: '', baudrate: 0 }`)
    defineEvent('connected', 'Port connected, listen only', 'Serial')
    defineEvent('deviceError', 'Error occurred', 'Device')
    self.on('connect', e => this.connect(e.detail))
    self.on('deviceError', e => self.emit('disconnected'))
    
    defineEvent('disconnect', 'Attempt to disconnect', 'Serial')
    defineEvent('disconnected', 'Port disconnected, listen only', 'Serial')
    defineEvent('deviceClosed', 'Device closed', 'Device')
    self.on('disconnect', e => this.serial && this.serial.close())
    self.on('disconnected', e => this.serial = null)
    self.on('deviceClosed', e => self.emit('disconnected'))
    
    defineEvent('serialData', 'New data from port', 'Serial', `{ data: '' }`)
    defineEvent('serialDirectWrite', 'Write data to port and skip buffer', 'Serial', `{ data: '' }`)
    self.on('serialDirectWrite', e => this.send(e.detail.data))
    
    // disconnect on close
    self.on('beforeunload', e => self.emit('disconnect'))
    
    setImmediate(() => {
      self.emit('disconnected')
      self.emit('refreshPorts')
    })
  }
  
  refreshPorts() {
    SerialPort = SerialPort || require('SerialPort')
    SerialPort.list((e, ports) => {
      if(e) throw e
      ports.reverse().forEach(port => {
        if(this.ports.some(p => p == port.comName)) return
        this.ports.push(port.comName)
        self.emit('newPort', port)
      })
      self.emit('refreshPortsDone')
    })
  }
  
  connect(e) {
    this.serial = new SerialPort(e.portName, {
      parser: SerialPort.parsers.readline('\n'),
      baudrate: parseInt(e.baudrate),
    })
    
    this.serial.on('open', () => self.emit('connected'))
    this.serial.on('close', () => self.emit('deviceClosed'))
    this.serial.on('error', e => { self.emit('deviceError', e); throw e; })
    this.serial.on('data', data => self.emit('serialData', { data }))
  }
  
  send(data) {
    if(!this.serial) return
    this.serial.write(data)
    if(data == 'M410\n') self.emit('msg', 'Moves aborted. Motors can be out of sync.')
  }
}
